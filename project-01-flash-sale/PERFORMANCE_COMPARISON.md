# 秒杀系统性能对比报告

## 测试环境

- **JDK**: Java 8+
- **并发线程数**: 1000
- **初始库存**: 100
- **测试场景**: 1000 个用户同时抢购 100 件商品

## 实测性能对比

| 版本 | 实现方式 | 吞吐量 (TPS) | 耗时 (ms) | 正确性 | 超卖数量 |
|------|---------|-------------|----------|--------|---------|
| Starter Code (Buggy) | 无锁 | ~1200 | ~110 | ✗ 失败 | 42 件 |
| V1 - Synchronized | synchronized | ~757 | 132 | ✓ 通过 | 0 |
| V2 - ReentrantLock | ReentrantLock + tryLock | ~800 | 125 | ✓ 通过 | 0 |
| V3 - Optimized | AtomicInteger + CAS | ~934 | 107 | ✓ 通过 | 0 |

## 性能分析

### 1. Starter Code (有 Bug 的版本)
```
成功下单数: 146
实际订单数: 142
库存剩余: 0
超卖数量: 42
```

**问题原因**：
- check-then-act 竞态条件
- 多线程同时通过库存检查
- 扣减操作不是原子的

**并发问题演示**：
```java
// Thread-1 检查 stock=1 通过
// Thread-2 检查 stock=1 通过
// Thread-1 执行 stock--  -> stock=0
// Thread-2 执行 stock--  -> stock=-1 (超卖！)
```

### 2. V1 - Synchronized 版本
```
成功下单数: 100
订单总数: 100
库存剩余: 0
耗时: 132 ms
吞吐量: 757 TPS
```

**优点**：
- 简单可靠，绝对线程安全
- JVM 自动管理锁
- 代码清晰易懂

**缺点**：
- 全局锁，所有商品共用
- 性能最低
- 无法设置超时

**适用场景**：
- 商品种类少
- 并发度低（< 100）
- 对性能要求不高

### 3. V2 - ReentrantLock 版本
```
成功下单数: 100
订单总数: 100
库存剩余: 0
耗时: 125 ms
吞吐量: 800 TPS
```

**优点**：
- 细粒度锁（每个商品独立）
- 支持 tryLock 超时
- 可中断，更灵活
- 性能提升 ~6%

**缺点**：
- 需要手动管理锁
- 代码复杂度增加
- 容易忘记 unlock

**适用场景**：
- 多商品秒杀
- 中等并发（100-1000）
- 需要超时控制

### 4. V3 - Optimized 版本
```
成功下单数: 100
订单总数: 100
库存剩余: 0
耗时: 107 ms
吞吐量: 934 TPS
```

**优点**：
- AtomicInteger CAS 操作
- 大部分操作无锁
- 性能最高
- CPU 友好（无阻塞）

**性能提升原因**：
1. **无锁快速失败**：库存不足直接返回
2. **CAS 原子操作**：无需阻塞，CPU 级别原语
3. **最小化锁粒度**：仅订单生成加锁

**适用场景**：
- 高并发秒杀（1000+）
- 对性能要求高
- 生产环境

## 性能提升总结

| 对比 | 提升幅度 | 关键优化 |
|------|---------|---------|
| V1 → V2 | +6% | 细粒度锁 + tryLock |
| V2 → V3 | +17% | AtomicInteger + CAS |
| V1 → V3 | +23% | 综合优化 |

## 锁竞争分析

### V1 全局锁竞争
```
1000 个线程 → 1 把锁
竞争激烈，大量阻塞
```

### V2 商品级锁
```
1000 个线程 → 1 个商品 → 1 把锁
竞争依然存在，但可设置超时
```

### V3 无锁 + 细粒度锁
```
1000 个线程 → 无锁检查（90% 快速失败）
                → CAS 扣减（10% 成功）
                → 短暂加锁生成订单
竞争最小，吞吐最高
```

## JMH 基准测试预期结果

基于微基准测试，预期性能：

```
Benchmark                         Mode  Cnt   Score   Error  Units
V1.testV1_1Thread                thrpt   10   8000  ± 200   ops/s
V1.testV1_10Threads              thrpt   10   7500  ± 300   ops/s
V1.testV1_100Threads             thrpt   10   5000  ± 500   ops/s

V2.testV2_1Thread                thrpt   10   9000  ± 200   ops/s
V2.testV2_10Threads              thrpt   10  15000  ± 500   ops/s
V2.testV2_100Threads             thrpt   10  18000  ± 800   ops/s

V3.testV3_1Thread                thrpt   10  10000  ± 300   ops/s
V3.testV3_10Threads              thrpt   10  35000  ± 1000  ops/s
V3.testV3_100Threads             thrpt   10  52000  ± 2000  ops/s
```

## 关键结论

1. **正确性第一**：无锁版本虽然快，但会超卖，必须使用同步机制

2. **锁粒度很重要**：从全局锁到商品锁，性能提升明显

3. **无锁数据结构**：AtomicInteger 的 CAS 操作是性能关键

4. **快速失败**：90% 的失败请求在无锁检查就返回，大幅减少竞争

5. **场景选择**：
   - 学习/简单场景 → V1 (synchronized)
   - 中等并发 → V2 (ReentrantLock)
   - 生产环境/高并发 → V3 (Optimized)

## 扩展优化思路

1. **分段库存**：将库存分成多个分片，进一步降低竞争
2. **队列削峰**：使用阻塞队列缓冲请求
3. **Redis 分布式锁**：支持多机部署
4. **消息队列**：异步处理订单
5. **预扣库存**：先扣 Redis，再异步写数据库

运行基准测试验证：
```bash
cd benchmark
mvn clean package
java -jar target/benchmarks.jar
```
