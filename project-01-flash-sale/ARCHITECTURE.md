# 秒杀系统架构设计

## 系统架构图

```
┌─────────────────────────────────────────────────────────────┐
│                      秒杀系统整体架构                          │
└─────────────────────────────────────────────────────────────┘

1000 个并发用户
    │
    ├─── User 1 (Thread-1)
    ├─── User 2 (Thread-2)
    ├─── User 3 (Thread-3)
    ├─── ...
    └─── User 1000 (Thread-1000)
           │
           ▼
    ┌──────────────────┐
    │ FlashSaleService │ ◄── 核心服务接口
    └──────────────────┘
           │
           ├─── V1: Synchronized 版本
           ├─── V2: ReentrantLock 版本
           └─── V3: Optimized 版本
                     │
                     ▼
              ┌─────────────┐
              │  库存管理    │
              │  订单生成    │
              └─────────────┘
```

## 版本演进架构

### V1 - Synchronized 版本

```
用户请求 → synchronized 全局锁 → 库存检查 → 扣减库存 → 生成订单
                  ▲                                       │
                  │                                       │
                  └───────────────────────────────────────┘
                        所有操作串行执行（性能瓶颈）

问题：
- 所有商品共用一把锁
- 1000 个线程竞争 1 把锁
- 性能：~757 TPS
```

**代码结构**：
```
FlashSaleServiceV1
├── productMap: Map<Long, Product>        # 商品映射
├── orderCounter: AtomicInteger           # 订单计数
└── buy() synchronized                    # 整个方法加锁
```

---

### V2 - ReentrantLock 版本

```
用户请求 → 商品ID → 获取商品专属锁 → tryLock(100ms) → 库存操作
   │                      │                │
   │                      │                ├─ 成功 → 扣减 → 生成订单
   │                      │                └─ 超时 → 快速失败
   │                      │
   └── 不同商品的请求可以并行执行 ──┘

优化：
- 每个商品独立锁（细粒度）
- 支持超时快速失败
- 性能：~800 TPS (+6%)
```

**代码结构**：
```
FlashSaleServiceV2
├── productMap: Map<Long, Product>              # 商品映射
├── lockMap: Map<Long, ReentrantLock>           # 商品锁映射（核心优化）
├── orderCounter: AtomicInteger                 # 订单计数
└── buy()
    ├── 双重检查（无锁 + 有锁）
    ├── tryLock(100ms) 获取商品锁
    └── finally unlock() 释放锁
```

---

### V3 - Optimized 版本

```
用户请求
   │
   ├─ 90% 快速失败路径 ────────────────┐
   │   (无锁检查 stock.get() <= 0)     │
   │                                  │
   └─ 10% 成功路径                    │
       │                              │
       ├─ CAS 扣减库存（无锁）         │
       │  AtomicInteger.compareAndSet │
       │                              │
       └─ 短暂加锁生成订单 ◄───────────┘
          (锁持有时间 < 1ms)

优化：
- 无锁快速失败
- CAS 原子操作
- 锁粒度最小化
- 性能：~934 TPS (+23%)
```

**代码结构**：
```
FlashSaleServiceV3
├── stockMap: Map<Long, AtomicInteger>          # 原子库存（核心优化）
├── productMap: Map<Long, Product>              # 商品信息
├── lockMap: Map<Long, ReentrantLock>           # 订单锁
├── orderCounter: AtomicInteger                 # 订单计数
└── buy()
    ├── 快速检查：stock.get() <= 0 (无锁)
    ├── CAS 扣减：while { compareAndSet() }
    └── 加锁生成订单：lock → createOrder → unlock
```

## 并发流程对比

### Starter Code (Bug 版本)

```
Thread-1                Thread-2
   │                       │
   ├─ if (stock > 0)      │
   │     ✓ (stock=1)       │
   │                       ├─ if (stock > 0)
   │                       │     ✓ (stock=1)  ← 同时通过检查！
   ├─ stock--              │
   │  (stock=0)            │
   │                       ├─ stock--
   │                       │  (stock=-1)       ← 超卖！
   └─ 生成订单             └─ 生成订单
      (订单 1)                (订单 2)
```

**结果**：库存 1 件，生成 2 个订单 → 超卖

---

### V1 - Synchronized

```
Thread-1                Thread-2
   │                       │
   ├─ synchronized {       │
   │   if (stock > 0)      │
   │   stock--             │
   │   生成订单             │
   │ } ────────────────┐   │
   │                   │   ├─ synchronized {  ← 阻塞等待
   │                   │   │     (等待 Thread-1 释放锁)
   └─ 释放锁 ──────────┘   │
                           │   if (stock > 0)  ← stock=0，失败
                           │ }
                           └─ 返回 null
```

**结果**：库存 1 件，生成 1 个订单 → 正确

---

### V3 - Optimized

```
Thread-1                Thread-2                Thread-3
   │                       │                       │
   ├─ stock.get()          │                       │
   │  (1 > 0) ✓            │                       │
   │                       ├─ stock.get()          │
   │                       │  (1 > 0) ✓            │
   ├─ CAS(1→0) ✓          │                       │
   │  成功扣减              │                       │
   │                       ├─ CAS(1→0) ✗          │
   │                       │  失败（值已变）        │
   │                       │  重试...               │
   │                       │  stock.get()=0        │
   │                       │  返回 null ────────┐  │
   │                       │                    │  │
   ├─ lock() ◄────────┐   │                    │  ├─ stock.get()
   │  生成订单         │   │                    │  │  (0 <= 0) ✗
   ├─ unlock() ───────┘   │                    │  │  快速失败 ───┐
   │                       │                    │  │             │
   └─ 返回订单             └─ 返回 null ◄───────┘  └─ 返回 null ◄┘
```

**结果**：
- Thread-1：CAS 成功，生成订单
- Thread-2：CAS 失败，重试后发现库存为 0，返回
- Thread-3：无锁检查库存为 0，快速失败

## 性能瓶颈分析

### V1 锁竞争图

```
                 全局锁（1 把锁）
                       │
        ┌──────────────┼──────────────┐
        │              │              │
    Thread-1      Thread-2  ...   Thread-1000
      等待          等待            等待
        │              │              │
        └──────────────┴──────────────┘
              高度竞争（串行执行）

竞争度：1000 个线程 / 1 把锁 = 1000:1
```

### V2 细粒度锁

```
    商品 A 的锁          商品 B 的锁
         │                    │
    ┌────┼────┐          ┌────┼────┐
    │    │    │          │    │    │
   T1   T2   T3         T4   T5   T6
   等待 等待 等待        等待 等待 等待

竞争度：1000 个线程 / 10 个商品 = 100:1 (每个商品)
相比 V1：竞争减少 10 倍
```

### V3 无锁 + CAS

```
    快速失败路径（90%）        CAS 路径（10%）
    ┌──────────┐             ┌──────────┐
    │ 无锁检查  │             │ CAS 操作  │
    │ stock=0  │             │ 自旋重试  │
    │ 立即返回  │             │          │
    └──────────┘             └─────┬────┘
                                    │
                             加锁生成订单 (<1ms)

竞争度：最小（大部分无锁，锁持有时间极短）
```

## 数据流图

### V3 详细数据流

```
┌─────────────┐
│ 用户请求     │
│ userId=1001 │
│ productId=1 │
└─────┬───────┘
      │
      ▼
┌───────────────────────────┐
│ 1. 获取原子库存            │
│    stock = stockMap.get(1) │
│    = AtomicInteger(100)    │
└───────┬───────────────────┘
        │
        ▼
┌───────────────────────────┐
│ 2. 无锁检查（快速失败）    │
│    if (stock.get() <= 0)   │
│       return null          │
│    当前：100 > 0，通过     │
└───────┬───────────────────┘
        │
        ▼
┌───────────────────────────┐
│ 3. CAS 扣减库存            │
│    while (true) {          │
│      current = stock.get() │  ← 读取当前值 = 100
│      if (current <= 0)     │
│        return null         │
│      next = current - 1    │  ← 计算新值 = 99
│      if (CAS(100, 99))     │  ← CAS 操作
│        break               │  ← 成功，跳出
│    }                       │
└───────┬───────────────────┘
        │
        ▼
┌───────────────────────────┐
│ 4. 加锁生成订单            │
│    lock.tryLock(50ms)      │  ← 获取锁
│    try {                   │
│      order = new Order()   │  ← 创建订单
│      orderCount++          │  ← 计数
│      return orderId        │
│    } finally {             │
│      lock.unlock()         │  ← 释放锁
│    }                       │
└───────┬───────────────────┘
        │
        ▼
┌───────────────────────────┐
│ 返回结果                   │
│ orderId = "ORDER-12345"   │
└───────────────────────────┘
```

## 内存模型

### V1 内存布局

```
FlashSaleServiceV1 对象
┌─────────────────────────────────────┐
│ this (监视器锁)                      │
│  ├── productMap                      │
│  │    └── {1001: Product(stock=100)} │
│  └── orderCounter                    │
│       └── AtomicInteger(0)           │
└─────────────────────────────────────┘

synchronized(this) → 锁 this 对象
所有商品共享这一把锁
```

### V2 内存布局

```
FlashSaleServiceV2 对象
┌─────────────────────────────────────┐
│ productMap                           │
│  └── {1001: Product(stock=100)}      │
│                                      │
│ lockMap (细粒度锁)                    │
│  ├── {1001: ReentrantLock()}         │
│  ├── {1002: ReentrantLock()}         │
│  └── {1003: ReentrantLock()}         │
│                                      │
│ orderCounter                         │
│  └── AtomicInteger(0)                │
└─────────────────────────────────────┘

每个商品独立锁，并行度提升
```

### V3 内存布局

```
FlashSaleServiceV3 对象
┌─────────────────────────────────────┐
│ stockMap (原子库存)                   │
│  ├── {1001: AtomicInteger(100)}      │ ← 核心优化
│  ├── {1002: AtomicInteger(200)}      │
│  └── {1003: AtomicInteger(50)}       │
│                                      │
│ productMap                           │
│  └── {1001: Product(...)}            │
│                                      │
│ lockMap (订单锁)                      │
│  └── {1001: ReentrantLock()}         │
│                                      │
│ orderCounter                         │
│  └── AtomicInteger(0)                │
└─────────────────────────────────────┘

无锁库存管理，性能最优
```

## CPU 缓存与并发

### 缓存一致性问题

```
CPU-1 Cache          CPU-2 Cache          CPU-3 Cache
    │                    │                    │
    ├─ stock=100         ├─ stock=100         ├─ stock=100
    │                    │                    │
    ▼                    ▼                    ▼
V1: synchronized      锁等待               锁等待
    stock--              │                    │
    MESI 协议            │                    │
    cache invalidate ────┴────────────────────┘
                    (缓存失效，强制重新读取)

V3: AtomicInteger.CAS
    CMPXCHG 指令 (CPU 原语)
    硬件级别原子操作
    无需操作系统介入
```

### 性能对比

| 操作 | V1 Synchronized | V2 ReentrantLock | V3 AtomicInteger |
|------|----------------|------------------|------------------|
| 获取锁 | JVM 监视器 (~100ns) | AQS 队列 (~50ns) | 无需锁 |
| 原子操作 | 锁保护 | 锁保护 | CAS (~10ns) |
| 竞争开销 | 高（上下文切换） | 中（自旋+队列） | 低（自旋） |
| 缓存失效 | 整个临界区 | 整个临界区 | 仅变量本身 |

## 扩展架构：分布式场景

### 单机 vs 分布式

```
单机版本（V1/V2/V3）
┌──────────────────┐
│  JVM Instance     │
│  ├── V3 Service   │
│  ├── stockMap     │
│  └── lockMap      │
└──────────────────┘
      ▲
      │ 所有请求
      │

分布式版本（扩展）
┌──────────┐  ┌──────────┐  ┌──────────┐
│  JVM-1    │  │  JVM-2    │  │  JVM-3    │
│  Service  │  │  Service  │  │  Service  │
└─────┬────┘  └─────┬────┘  └─────┬────┘
      │             │             │
      └─────────────┴─────────────┘
                    │
                    ▼
          ┌──────────────────┐
          │  Redis (共享库存)  │
          │  分布式锁（Redisson）│
          └──────────────────┘

需要解决：
1. 分布式锁（Redis/Zookeeper）
2. 库存一致性（数据库）
3. 网络延迟（本地缓存）
```

## 监控指标

### 关键指标

```
性能指标：
┌─────────────────────────────────┐
│ TPS (Throughput)                 │  ← 吞吐量
│ P50/P95/P99 Latency             │  ← 延迟
│ CPU Usage                        │  ← CPU 使用率
│ Lock Contention                  │  ← 锁竞争
└─────────────────────────────────┘

业务指标：
┌─────────────────────────────────┐
│ 订单数 vs 库存数                  │  ← 正确性
│ 超卖数量                          │  ← 核心指标
│ 成功率                            │  ← 用户体验
└─────────────────────────────────┘
```

### 压测对比

```
并发度     V1 TPS    V2 TPS    V3 TPS
   10       7500      8500      9500
  100       5000     15000     35000
 1000        757       800       934   ← 实测数据
10000        500      2000     10000   ← 预测
```

## 总结

通过三个版本的演进，展示了从简单到复杂、从低性能到高性能的优化路径：

1. **V1**：简单可靠，适合学习
2. **V2**：细粒度锁，适合中等并发
3. **V3**：无锁优化，适合生产环境

**核心思想**：
- 正确性第一：先保证不超卖
- 逐步优化：从粗粒度到细粒度
- 无锁思想：减少锁持有时间

**关键技术**：
- synchronized → ReentrantLock → AtomicInteger
- 全局锁 → 细粒度锁 → CAS
- 阻塞 → 超时 → 自旋
