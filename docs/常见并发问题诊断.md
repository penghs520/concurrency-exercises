# 常见并发问题诊断

## 并发Bug的特点

- **难以复现**：依赖线程调度的时序
- **间歇性出现**：生产环境偶尔触发
- **难以调试**：加日志/断点可能改变时序
- **影响严重**：数据不一致、死锁、系统崩溃

---

## 一、死锁（Deadlock）

### 1.1 定义与特征

> 两个或多个线程互相持有对方需要的资源，导致所有线程都无法继续执行

#### 死锁的四个必要条件
1. **互斥条件**：资源不能被共享
2. **持有并等待**：已持有资源的同时等待其他资源
3. **不可剥夺**：资源不能被强制抢占
4. **循环等待**：存在资源的循环依赖链

### 1.2 经典死锁示例

#### 示例1：账户转账死锁
```java
public class DeadlockDemo {
    public void transfer(Account from, Account to, int amount) {
        synchronized (from) {           // 线程1: 锁定A账户
            synchronized (to) {         // 等待B账户
                from.debit(amount);
                to.credit(amount);
            }
        }
    }

    // 线程1: transfer(A, B, 100)  -> 锁A等B
    // 线程2: transfer(B, A, 200)  -> 锁B等A  [死锁！]
}
```

#### 示例2：循环依赖死锁
```java
class ResourceA {
    synchronized void methodA(ResourceB b) {
        b.last(); // 需要b的锁
    }
    synchronized void last() {}
}

class ResourceB {
    synchronized void methodB(ResourceA a) {
        a.last(); // 需要a的锁
    }
    synchronized void last() {}
}

// 线程1: a.methodA(b) -> 持有a锁，等待b锁
// 线程2: b.methodB(a) -> 持有b锁，等待a锁 [死锁！]
```

### 1.3 死锁诊断

#### 方法1：jstack线程Dump
```bash
# 1. 找到Java进程ID
jps -l

# 2. 生成线程Dump
jstack <pid> > thread_dump.txt

# 3. 查找死锁信息
grep -A 10 "Found one Java-level deadlock" thread_dump.txt
```

**输出示例**：
```
Found one Java-level deadlock:
=============================
"Thread-1":
  waiting to lock monitor 0x00007f8b1c004e00 (object 0x00000007d5f3e3a0, a Account),
  which is held by "Thread-0"
"Thread-0":
  waiting to lock monitor 0x00007f8b1c007350 (object 0x00000007d5f3e3b0, a Account),
  which is held by "Thread-1"
```

#### 方法2：JConsole可视化
1. 启动JConsole: `jconsole`
2. 连接到目标进程
3. 切换到"线程"标签
4. 点击"检测死锁"按钮

#### 方法3：编程方式检测
```java
ThreadMXBean tmx = ManagementFactory.getThreadMXBean();
long[] deadlockedThreads = tmx.findDeadlockedThreads();

if (deadlockedThreads != null) {
    ThreadInfo[] threadInfos = tmx.getThreadInfo(deadlockedThreads);
    for (ThreadInfo ti : threadInfos) {
        System.out.println("死锁线程: " + ti.getThreadName());
        System.out.println("等待锁: " + ti.getLockName());
        System.out.println("锁持有者: " + ti.getLockOwnerName());
    }
}
```

### 1.4 死锁预防与解决

#### 策略1：破坏"持有并等待" - 一次性申请所有资源
```java
// ✗ 容易死锁
synchronized (lockA) {
    synchronized (lockB) { ... }
}

// ✓ 一次性获取
class ResourceManager {
    public boolean tryAcquire(Lock... locks) {
        for (Lock lock : locks) {
            if (!lock.tryLock()) {
                // 释放已获取的锁
                for (Lock acquired : locks) {
                    if (acquired.isHeldByCurrentThread()) {
                        acquired.unlock();
                    }
                }
                return false;
            }
        }
        return true;
    }
}
```

#### 策略2：破坏"循环等待" - 按顺序加锁
```java
public void transfer(Account from, Account to, int amount) {
    Account first = from.getId() < to.getId() ? from : to;
    Account second = first == from ? to : from;

    synchronized (first) {   // 总是先锁ID小的
        synchronized (second) {
            from.debit(amount);
            to.credit(amount);
        }
    }
}
```

#### 策略3：使用tryLock设置超时
```java
Lock lock1 = new ReentrantLock();
Lock lock2 = new ReentrantLock();

if (lock1.tryLock(100, TimeUnit.MILLISECONDS)) {
    try {
        if (lock2.tryLock(100, TimeUnit.MILLISECONDS)) {
            try {
                // 临界区
            } finally {
                lock2.unlock();
            }
        }
    } finally {
        lock1.unlock();
    }
}
```

#### 策略4：使用Semaphore限制并发数
```java
Semaphore semaphore = new Semaphore(1); // 最多1个线程访问资源

semaphore.acquire();
try {
    // 访问共享资源
} finally {
    semaphore.release();
}
```

---

## 二、活锁（Livelock）

### 2.1 定义
> 线程不断重试某个操作，但每次都失败，系统看起来在运行但没有进展

### 2.2 示例
```java
public class LivelockDemo {
    static class Spoon {
        private Diner owner;

        public synchronized void use() {
            System.out.println(owner.name + " 使用勺子");
        }

        public synchronized void setOwner(Diner d) {
            owner = d;
        }
    }

    static class Diner {
        String name;
        boolean isHungry;

        public void eatWith(Spoon spoon, Diner spouse) {
            while (isHungry) {
                if (spoon.owner != this) {
                    Thread.yield(); // 等待
                    continue;
                }

                // 如果配偶饿了，让出勺子
                if (spouse.isHungry) {
                    spoon.setOwner(spouse);
                    continue; // [活锁：互相谦让]
                }

                spoon.use();
                isHungry = false;
                spoon.setOwner(spouse);
            }
        }
    }
}
```

### 2.3 解决方案
```java
// 引入随机性，打破对称性
if (spouse.isHungry && Math.random() < 0.5) {
    spoon.setOwner(spouse);
}
```

---

## 三、线程饥饿（Starvation）

### 3.1 定义
> 某些线程长时间或永远得不到CPU执行机会

### 3.2 常见原因

#### 原因1：优先级设置不当
```java
Thread highPriority = new Thread(() -> {
    while (true) { /* 一直占用CPU */ }
});
highPriority.setPriority(Thread.MAX_PRIORITY);

Thread lowPriority = new Thread(() -> { /* ... */ });
lowPriority.setPriority(Thread.MIN_PRIORITY); // 可能饥饿
```

#### 原因2：不公平锁
```java
// 非公平锁：新线程可能插队
ReentrantLock unfairLock = new ReentrantLock(false);

// 公平锁：按请求顺序获取锁
ReentrantLock fairLock = new ReentrantLock(true);
```

#### 原因3：无限等待锁
```java
// ✗ 可能永远等不到锁
synchronized (lock) { /* ... */ }

// ✓ 设置超时
if (lock.tryLock(10, TimeUnit.SECONDS)) {
    try { /* ... */ }
    finally { lock.unlock(); }
} else {
    // 处理获取锁失败
}
```

### 3.3 解决方案
- 使用公平锁（性能会下降）
- 避免在锁内执行耗时操作
- 使用tryLock避免无限等待

---

## 四、竞态条件（Race Condition）

### 4.1 Check-Then-Act
```java
// ✗ 非线程安全
if (!map.containsKey(key)) {  // [1] 检查
    map.put(key, value);      // [2] 操作
}

// 线程A: [1]检查(false) -> [切换]
// 线程B: [1]检查(false) -> [2]put
// 线程A: [2]put  [覆盖线程B的值！]
```

**解决方案**：
```java
// ✓ 使用原子方法
map.putIfAbsent(key, value);

// ✓ 或加锁
synchronized (map) {
    if (!map.containsKey(key)) {
        map.put(key, value);
    }
}
```

### 4.2 Read-Modify-Write
```java
// ✗ 非原子操作
count++;

// 等价于：
// temp = count;  [读]
// temp = temp + 1; [改]
// count = temp;  [写]
```

**解决方案**：
```java
AtomicInteger count = new AtomicInteger(0);
count.incrementAndGet(); // CAS原子操作
```

### 4.3 懒加载单例
```java
// ✗ 非线程安全
public class Singleton {
    private static Singleton instance;

    public static Singleton getInstance() {
        if (instance == null) {       // [1] 检查
            instance = new Singleton(); // [2] 创建
        }
        return instance;
    }
}
```

**解决方案**（见双重检查锁定）

---

## 五、内存可见性问题

### 5.1 循环不退出
```java
public class VisibilityDemo {
    private boolean flag = false; // 缺少volatile!

    // 线程1
    public void writer() {
        flag = true;
    }

    // 线程2
    public void reader() {
        while (!flag) { // 可能永远循环
            // JIT编译器可能优化为 while(true)
        }
        System.out.println("退出循环");
    }
}
```

**解决方案**：
```java
private volatile boolean flag = false;
```

### 5.2 诊断方法
```bash
# 1. 检查JIT编译
java -XX:+PrintCompilation YourApp

# 2. 禁用JIT编译测试
java -Xint YourApp

# 3. 使用volatile或synchronized
```

---

## 六、线程池问题

### 6.1 任务堆积导致OOM
```java
// ✗ 无界队列，可能OOM
ExecutorService executor = Executors.newFixedThreadPool(10);
// 内部使用 LinkedBlockingQueue (无界)

for (int i = 0; i < Integer.MAX_VALUE; i++) {
    executor.submit(() -> {
        Thread.sleep(10000); // 慢任务
    });
} // [OutOfMemoryError!]
```

**解决方案**：
```java
// ✓ 有界队列 + 拒绝策略
ThreadPoolExecutor executor = new ThreadPoolExecutor(
    10, 20,
    60, TimeUnit.SECONDS,
    new ArrayBlockingQueue<>(1000), // 有界
    new ThreadPoolExecutor.CallerRunsPolicy() // 拒绝策略
);
```

### 6.2 线程池过小导致饥饿死锁
```java
ExecutorService executor = Executors.newSingleThreadExecutor();

executor.submit(() -> {
    Future<String> future = executor.submit(() -> "inner task");
    return future.get(); // [死锁：等待自己提交的任务]
});
```

**解决方案**：
- 使用足够大的线程池
- 避免嵌套提交任务

### 6.3 未正确关闭线程池
```java
// ✗ 程序无法退出
ExecutorService executor = Executors.newFixedThreadPool(10);
// ... 使用线程池
// [忘记shutdown]

// ✓ 正确关闭
executor.shutdown(); // 不接受新任务
if (!executor.awaitTermination(60, TimeUnit.SECONDS)) {
    executor.shutdownNow(); // 强制关闭
}
```

---

## 七、性能问题

### 7.1 锁粒度过大
```java
// ✗ 锁粒度太大
public class Cache {
    private final Map<String, Object> cache = new HashMap<>();

    public synchronized Object get(String key) { // 读也加锁
        return cache.get(key);
    }

    public synchronized void put(String key, Object value) {
        cache.put(key, value);
    }
}
```

**解决方案**：
```java
// ✓ 使用读写锁
private final ReadWriteLock rwLock = new ReentrantReadWriteLock();
private final Map<String, Object> cache = new HashMap<>();

public Object get(String key) {
    rwLock.readLock().lock();
    try {
        return cache.get(key);
    } finally {
        rwLock.readLock().unlock();
    }
}

// ✓ 或使用ConcurrentHashMap
private final Map<String, Object> cache = new ConcurrentHashMap<>();
```

### 7.2 频繁的上下文切换
```bash
# 查看上下文切换次数
vmstat 1

# 查看线程数
ps -eLf | wc -l

# 线程Dump分析
jstack <pid> | grep "BLOCKED\|WAITING" | wc -l
```

**优化方法**：
- 减少线程数量
- 使用无锁数据结构（CAS）
- 减少锁的持有时间

### 7.3 伪共享（False Sharing）
```java
// ✗ 伪共享
class Counter {
    volatile long count1; // 可能与count2在同一缓存行
    volatile long count2;
}
```

**解决方案**：
```java
// ✓ 填充避免伪共享
class Counter {
    volatile long count1;
    long p1, p2, p3, p4, p5, p6, p7; // 填充
    volatile long count2;
}

// ✓ 或使用@Contended (JDK 8+)
class Counter {
    @sun.misc.Contended
    volatile long count1;

    @sun.misc.Contended
    volatile long count2;
}
```

---

## 八、诊断工具箱

### 8.1 JDK自带工具

| 工具 | 用途 | 命令示例 |
|------|------|---------|
| **jps** | 查看Java进程 | `jps -l` |
| **jstack** | 线程Dump | `jstack <pid>` |
| **jstat** | GC统计 | `jstat -gc <pid> 1000` |
| **jmap** | 堆Dump | `jmap -dump:file=heap.bin <pid>` |
| **jconsole** | 图形化监控 | `jconsole` |
| **jvisualvm** | 可视化分析 | `jvisualvm` |

### 8.2 第三方工具
- **Arthas**：阿里开源诊断工具
- **MAT**：内存分析工具
- **JProfiler**：商业性能分析工具
- **YourKit**：商业性能分析工具

### 8.3 代码层面工具
```java
// 1. 检测死锁
ThreadMXBean tmx = ManagementFactory.getThreadMXBean();
long[] deadlocked = tmx.findDeadlockedThreads();

// 2. 监控锁竞争
ThreadInfo[] threadInfos = tmx.getThreadInfo(
    tmx.getAllThreadIds(), true, true
);

// 3. CPU使用率
OperatingSystemMXBean osBean = ManagementFactory.getOperatingSystemMXBean();
double cpuLoad = osBean.getSystemLoadAverage();
```

---

## 九、最佳实践清单

### 开发阶段
- [ ] 最小化共享可变状态
- [ ] 使用不可变对象
- [ ] 优先使用并发工具类（Atomic*, Concurrent*）
- [ ] 遵循加锁顺序，避免死锁
- [ ] 缩小锁的范围
- [ ] 避免在锁内调用外部方法

### 测试阶段
- [ ] 编写并发测试用例
- [ ] 使用压力测试工具（JMeter）
- [ ] 使用静态分析工具（SpotBugs）
- [ ] 进行长时间运行测试（Soak Test）

### 生产环境
- [ ] 配置JVM参数记录线程Dump
  ```bash
  -XX:+HeapDumpOnOutOfMemoryError
  -XX:HeapDumpPath=/path/to/dumps
  ```
- [ ] 监控线程数、锁竞争
- [ ] 配置合理的超时时间
- [ ] 建立应急响应预案

---

## 十、快速排查流程

```
1. 观察现象
   ├─ CPU 100%？ -> 可能死循环或GC
   ├─ 响应慢？   -> 可能死锁或饥饿
   └─ OOM？      -> 可能内存泄漏

2. 生成Dump
   ├─ jstack <pid> > thread.txt (线程Dump)
   └─ jmap -dump <pid> (堆Dump)

3. 分析Dump
   ├─ 查找"deadlock"关键字
   ├─ 查看BLOCKED/WAITING线程
   └─ 分析锁持有关系

4. 定位代码
   └─ 根据堆栈信息找到问题代码

5. 修复验证
   ├─ 本地复现问题
   ├─ 修复并测试
   └─ 上线观察
```

---

**记住**：并发问题预防远胜于事后排查，编写代码时就要考虑线程安全！
