# 并发基础理论

## 为什么需要并发？

### 1. 提高程序性能
- **充分利用多核CPU**：现代CPU都是多核心，单线程只能利用一个核心
- **提高CPU利用率**：I/O操作时，其他线程可以继续执行
- **提升系统吞吐量**：同时处理多个请求

### 2. 改善用户体验
- **响应式界面**：UI线程不阻塞，保持流畅
- **后台任务**：下载、上传等耗时操作不影响主流程

### 3. 真实世界模拟
- Web服务器同时处理多个客户端请求
- 订单系统并发处理多笔交易

---

## 并发 vs 并行

### 并发（Concurrency）
> 同一时间段内，多个任务交替执行

```
时间线: ---|Task A|-----|Task A|-----|Task A|---
           -----|Task B|-----|Task B|-----|Task B|
```

- **特点**：宏观上同时进行，微观上交替执行
- **场景**：单核CPU的多线程

### 并行（Parallelism）
> 同一时刻，多个任务同时执行

```
时间线: ---|Task A|Task A|Task A|---
           ---|Task B|Task B|Task B|---
```

- **特点**：真正的同时执行
- **场景**：多核CPU，每个核心运行一个线程

### 关键区别
| 维度 | 并发 | 并行 |
|------|------|------|
| 定义 | 处理多个任务的能力 | 同时执行多个任务 |
| 硬件要求 | 单核即可 | 必须多核 |
| 实现方式 | 时间片轮转 | 多处理器 |
| 目的 | 提高效率，避免阻塞 | 提高性能 |

---

## 进程 vs 线程

### 进程（Process）
- **定义**：操作系统资源分配的基本单位
- **特点**：
  - 独立的内存空间
  - 拥有独立的系统资源
  - 进程间通信（IPC）开销大
  - 创建/销毁成本高

### 线程（Thread）
- **定义**：CPU调度的基本单位
- **特点**：
  - 共享进程的内存空间
  - 拥有独立的栈和程序计数器
  - 线程间通信简单（共享内存）
  - 创建/销毁成本低

### 对比图示
```
进程1                 进程2
┌──────────────┐    ┌──────────────┐
│  代码段       │    │  代码段       │
│  数据段       │    │  数据段       │
│              │    │              │
│  ┌────────┐  │    │  ┌────────┐  │
│  │线程1   │  │    │  │线程1   │  │
│  │ 栈     │  │    │  │ 栈     │  │
│  └────────┘  │    │  └────────┘  │
│  ┌────────┐  │    │              │
│  │线程2   │  │    │              │
│  │ 栈     │  │    │              │
│  └────────┘  │    │              │
└──────────────┘    └──────────────┘
```

---

## 线程安全问题

### 什么是线程安全？
> 当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要额外的同步，调用这个对象的行为都可以获得正确的结果，那这个对象就是线程安全的。

### 线程不安全示例

#### 示例1：i++操作
```java
public class Counter {
    private int count = 0;

    public void increment() {
        count++; // 非原子操作！
    }
}
```

**问题分析**：
```
count++ 实际分为三步：
1. 读取count的值到寄存器
2. 寄存器值+1
3. 写回count

线程1: read(0) -> add(1) -> [切换] -> write(1)
线程2:         -> read(0) -> add(1) -> write(1) [✗ 丢失更新]
```

#### 示例2：竞态条件（Race Condition）
```java
public class LazyInitRace {
    private ExpensiveObject instance = null;

    public ExpensiveObject getInstance() {
        if (instance == null) { // [1] 检查
            instance = new ExpensiveObject(); // [2] 创建
        }
        return instance;
    }
}
```

**问题分析**：
```
线程1: 检查(null) -> [切换] -> 创建对象A
线程2:            -> 检查(null) -> 创建对象B [✗ 创建多个实例]
```

---

## 线程安全的三大特性

### 1. 原子性（Atomicity）
> 一个操作或一系列操作，要么全部执行且不被打断，要么全部不执行

#### 保证原子性的方法
- `synchronized`
- `Lock`
- `Atomic*` 原子类

#### 示例
```java
// ✗ 非原子
count++;

// ✓ 原子
AtomicInteger count = new AtomicInteger();
count.incrementAndGet();
```

### 2. 可见性（Visibility）
> 一个线程修改了共享变量，其他线程能立即看到最新值

#### 可见性问题
```java
public class VisibilityDemo {
    private boolean flag = false; // 没有volatile

    public void writer() {
        flag = true; // 线程1修改
    }

    public void reader() {
        while (!flag) { // 线程2可能永远看不到true
            // ...
        }
    }
}
```

#### 保证可见性的方法
- `volatile` 关键字
- `synchronized`
- `Lock`
- `final`（构造函数中初始化）

### 3. 有序性（Ordering）
> 程序执行的顺序按照代码的先后顺序执行

#### 指令重排序
```java
// 原始代码
int a = 1;  // [1]
int b = 2;  // [2]
int c = a + b; // [3]

// 可能被重排序为
int b = 2;  // [2]
int a = 1;  // [1]
int c = a + b; // [3]
```

#### 重排序导致的问题（双重检查锁定）
```java
public class Singleton {
    private static Singleton instance;

    public static Singleton getInstance() {
        if (instance == null) {
            synchronized (Singleton.class) {
                if (instance == null) {
                    instance = new Singleton(); // [问题！]
                }
            }
        }
        return instance;
    }
}
```

**问题分析**：
```
new Singleton() 分为三步：
1. 分配内存
2. 初始化对象
3. 指向内存地址

可能被重排序为：
1. 分配内存
3. 指向内存地址 [此时instance != null但对象未初始化]
2. 初始化对象

线程A: 创建到步骤3 -> [切换]
线程B: 检查instance != null -> 返回未初始化的对象 [✗ 错误]
```

**解决方案**：
```java
private static volatile Singleton instance; // 加volatile禁止重排序
```

---

## 线程安全的实现方式

### 1. 互斥同步（阻塞同步）
通过锁机制确保同一时刻只有一个线程访问共享资源

#### synchronized
```java
public synchronized void method() {
    // 同步方法
}

synchronized (lock) {
    // 同步代码块
}
```

#### Lock接口
```java
Lock lock = new ReentrantLock();
lock.lock();
try {
    // 临界区
} finally {
    lock.unlock();
}
```

**优缺点**：
- ✓ 简单易用，保证正确性
- ✗ 性能开销大（线程阻塞、上下文切换）

### 2. 非阻塞同步（无锁）
基于CAS（Compare-And-Swap）实现

```java
AtomicInteger count = new AtomicInteger(0);
count.incrementAndGet(); // CAS实现
```

**优缺点**：
- ✓ 性能高，无阻塞
- ✗ 只能保证单个变量的原子性
- ✗ ABA问题

### 3. 不可变对象
对象创建后状态不可修改，天然线程安全

```java
public final class ImmutablePoint {
    private final int x;
    private final int y;

    public ImmutablePoint(int x, int y) {
        this.x = x;
        this.y = y;
    }

    // 只有getter，没有setter
}
```

**优缺点**：
- ✓ 绝对线程安全
- ✓ 可以自由共享
- ✗ 每次修改都需要创建新对象

### 4. 线程本地存储（ThreadLocal）
每个线程拥有变量的独立副本

```java
ThreadLocal<SimpleDateFormat> dateFormat =
    ThreadLocal.withInitial(() -> new SimpleDateFormat("yyyy-MM-dd"));

// 每个线程获取自己的副本
SimpleDateFormat sdf = dateFormat.get();
```

---

## 常见并发问题

### 1. 死锁（Deadlock）
两个或多个线程互相等待对方释放锁

```java
// 线程1
synchronized (lockA) {
    synchronized (lockB) { ... }
}

// 线程2
synchronized (lockB) {
    synchronized (lockA) { ... }
}
```

**死锁的四个必要条件**：
1. 互斥条件
2. 持有并等待
3. 不可剥夺
4. 循环等待

### 2. 活锁（Livelock）
线程不断重试但总是失败

### 3. 饥饿（Starvation）
某些线程永远得不到执行机会

---

## 性能指标

### 1. 吞吐量（Throughput）
单位时间内完成的任务数

### 2. 响应时间（Latency）
从请求到响应的时间

### 3. CPU利用率
CPU忙碌时间的比例

### Amdahl定律
```
加速比 = 1 / (S + (1-S)/N)

S: 串行部分比例
N: 处理器数量
```

**启示**：并发程序的性能提升受限于串行部分

---

## 最佳实践

### 1. 缩小锁的范围
```java
// ✗ 不好
public synchronized void method() {
    doSomething(); // 不需要同步
    criticalSection(); // 需要同步
    doOthers(); // 不需要同步
}

// ✓ 好
public void method() {
    doSomething();
    synchronized (this) {
        criticalSection();
    }
    doOthers();
}
```

### 2. 优先使用并发工具类
```java
// ✗ 手动实现
synchronized (map) {
    if (!map.containsKey(key)) {
        map.put(key, value);
    }
}

// ✓ 使用ConcurrentHashMap
map.putIfAbsent(key, value);
```

### 3. 避免在锁内做耗时操作
```java
// ✗ 不好
synchronized (lock) {
    // 网络I/O - 很慢！
    readFromNetwork();
}

// ✓ 好
Data data = readFromNetwork();
synchronized (lock) {
    processData(data);
}
```

---

## 总结

并发编程的核心是**理解和控制共享可变状态的访问**：
1. 尽量避免共享（ThreadLocal、不可变对象）
2. 必须共享时，确保线程安全（同步、原子类）
3. 权衡性能与安全（无锁 vs 有锁）

**记住**：并发Bug往往难以复现和调试，预防胜于治疗！
